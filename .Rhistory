resettest(credittrue2, power = 2:3, type = 'regressor')
resettest(credittrue2, power = 2:3, type = 'fitted')
ncvTest(credittrue2)
bptest(credittrue2)
vif(credittrue2)
outlierTest(credittrue2)
infl <- data.frame(
hat = hatvalues(credittrue2),
cooks = cooks.distance(credittrue2),
rstandard = rstandard(credittrue2),
rstudent = rstudent(credittrue2)
)
infl <- infl[order(infl$cooks, decreasing = TRUE),]
print(head(infl))
Anova(credittrue2, type = 'II')
avPlots(credittrue2, ask = FALSE)
anova(credittrue2, credittrue)
credittrue3 <- lm(Balance_log~bs(log(Income), df = 8)+bs(log(Limit), df = 8)+bs(log(Income), df = 8)*Student+bs(log(Limit), df = 8)*Student+Student, data = Credit)
anova(credittrue3, credittrue2)
par(mfrow=c(2,2), ask = FALSE)
plot(credittrue3)
residualPlots(credittrue3, ask = FALSE)
resettest(credittrue3, power = 2:3, type = 'regressor')
resettest(credittrue3, power = 2:3, type = 'fitted')
ncvTest(credittrue3)
bptest(credittrue3)
vif(credittrue3)
outlierTest(credittrue3)
infl <- data.frame(
hat = hatvalues(credittrue3),
cooks = cooks.distance(credittrue3),
rstandard = rstandard(credittrue3),
rstudent = rstudent(credittrue3)
)
infl <- infl[order(infl$cooks, decreasing = TRUE), ]
print(head(infl))
print(summary(credittrue3))
Anova(credittrue3, type = 'III')
avPlots(credittrue3, ask = FALSE)
plot(Effect('Income', credittrue))
plot(Effect('Limit', credittrue))
powers <- seq(1.1, 1.8, by = 0.1)
#Credit$Limit_log <- log(Credit$Limit + 1)
p_prof <- tweedie.profile(Balance~Income*log(Limit)+bs(Rating, df = 4)+Cards+Age+Education+Gender+Student+Married+Ethnicity, data = Credit, p.vec = powers, control = glm.control(maxit = 10000))
best_p <- p_prof$p.max
print(paste('best P:', best_p))
credittweed <- glm(Balance~Income*log(Limit)+bs(Rating, df = 4)+Cards+Age+Education+Gender+Student+Married+Ethnicity, data = Credit, family = tweedie(var.power = best_p, link.power = 0))
summary(credittweed)
Anova(credittweed, test.statistic = 'Wald')
par(mfrow=c(2,2), ask = FALSE)
plot(credittweed)
idsx <- NULL
for(name in colnames(model.matrix(credittweed))[-1]){
idsx <- c(idsx, name)
}
par(mfrow=c(3,4), ask = FALSE)
for(i in idsx){
plot(model.matrix(credittweed)[,i], resid(credittweed, type = 'deviance'), xlab = i, ylab = 'Deviance Residuals')
abline(h=0, col = 'red')
}
par(mfrow=c(1,1), ask = FALSE)
print(paste("Deviance:", pchisq(deviance(credittweed), df.residual(credittweed), lower = FALSE)))
idsx <- NULL
for( i in colnames(model.matrix(credittweed))[-1]){
idsx <- c(idsx, i)
}
par(mfrow = c(3,4), ask = FALSE)
for(i in idsx){
partial <- model.matrix(credittweed)[,i]*credittweed$coefficients[i]+residuals(credittweed, type = 'deviance')
plot(model.matrix(credittweed)[,i], partial, xlab = i, ylab = 'Partial Devaince Residuals')
abline(h = 0, col = 'red')
}
par(mfrow=c(1,1), ask = FALSE)
residualPlots(credittweed, ask = FALSE)
print(sum(residuals(credittweed, type = 'pearson')^2)/(df.residual(credittweed)))
vif(credittweed)
infl <- data.frame(
hat = hatvalues(credittweed),
cooks = cooks.distance(credittweed),
rstandard = rstandard(credittweed),
rstudent = rstudent(credittweed)
)
infl <- infl[order(infl$cooks, decreasing = TRUE),]
head(infl)
Credit$has_bal <-(Credit$Balance > 0)
creditbin <- glm(has_bal~Income+Limit+Cards+Age+Education+Gender+Married+Ethnicity, data = Credit, family = 'binomial')
print(summary(creditbin))
Anova(creditbin, test.statistic = 'Wald')
par(mfrow=c(2,2), ask = FALSE)
plot(creditbin)
binnedplot(predict(creditbin), residuals(creditbin))
binnedplot(creditbin$fitted.values, model.response(model.frame(creditbin)), xlab = 'Mean Predicted Probability', ylab = 'Observed Fraction', main = 'Calibration Plot')
abline(0, 1, lty = 2)
idsx <- NULL
for(i in colnames(model.matrix(creditbin))[-1]){
idsx <- c(idsx,i)
}
par(mfrow = c(3,4), ask = FALSE)
for(i in idsx){
binnedplot(model.matrix(creditbin)[,i], residuals(creditbin), xlab = i, ylab = 'Deviance Residuals (binned)')
abline(h = 0, col = 'red')
}
par(mfrow = c(1,1), ask = FALSE)
idsx <- NULL
for(i in colnames(model.matrix(creditbin))[-1]){
idsx <- c(idsx, i)
}
par(mfrow=c(3,4), ask = FALSE)
for(i in idsx){
partial <- model.matrix(creditbin)[,i]*creditbin$coefficients[i] + residuals(creditbin, type = 'working')
plot(model.matrix(creditbin)[,i], partial, xlab = i, ylab = 'Partial Residuals')
abline(h = 0, col = 'red')
}
par(mfrow=c(1,1), ask = FALSE)
residualPlots(creditbin, ask = FALSE)
print(sum(residuals(creditbin, type = 'pearson')^2)/df.residual(creditbin))
vif(creditbin)
infl <- data.frame(
hat = hatvalues(creditbin),
cooks = cooks.distance(creditbin),
rstandard = rstandard(creditbin),
rstudent = rstudent(creditbin)
)
infl <- infl[order(infl$cooks, decreasing = TRUE), ]
head(infl)
y_true <- Credit$has_bal
y_score <- predict(creditbin, type = 'response')
pr <- pr.curve(scores.class0 = y_score[y_true == TRUE],
scores.class1 = y_score[y_true == FALSE],
curve = TRUE)
plot(pr)
pr$auc.integral
library(caret)
cands <- quantile(y_score, seq(0.05, 0.95, by = 0.05))
results <- data.frame()
for(t in cands){
pred <- factor(ifelse(y_score > t, 1, 0), levels = c(0,1))
truth <- factor(y_true, levels = c(0,1))
cm <- confusionMatrix(pred, truth, positive = '1')
results <- rbind(
results,
data.frame(
threshold = t,
precision = cm$byClass["Precision"],
recall    = cm$byClass["Recall"],
F1        = cm$byClass["F1"]
)
)
}
results
cred <- Credit[Credit$Balance > 0,]
plot(cred)
summary(cred)
creditgam <- glm(Balance~Income*log(Limit)+bs(Rating, df = 4)+Cards+Age+Education+Gender+Student+Married+Ethnicity, data = cred, family = Gamma(link = 'log'))
print(summary(creditgam))
par(mfrow = c(2,2), ask = FALSE)
plot(creditgam)
idsx <- NULL
for(i in colnames(model.matrix(creditgam))[-1]){
idsx <- c(idsx, i)
}
par(mfrow = c(3,4), ask = FALSE)
for(i in idsx){
plot(model.matrix(creditgam)[,i], residuals(creditgam, type = 'deviance'), xlab = i, ylab = 'Deviance Residuals', main = 'Deviance Residuals')
}
par(mfrow = c(1,1), ask = FALSE)
print(pchisq(deviance(creditgam), df.residual(creditgam), lower = FALSE))
idsx <- NULL
for(i in colnames(model.matrix(creditgam))[-1]){
idsx <- c(idsx, i)
}
par(mfrow = c(3,4), ask = FALSE)
for(i in idsx){
partial <- model.matrix(creditgam)[,i] * creditgam$coefficients[i] + residuals(creditgam, type = 'deviance')
plot(model.matrix(creditgam)[,i], partial, xlab = i, ylab = 'Partial Residuals', main = 'Partial Residuals')
}
par(mfrow = c(1,1), ask = FALSE)
residualPlots(creditgam, ask = FALSE)
print(sum(residuals(creditgam, type = 'pearson')^2)/df.residual(creditgam))
vif(creditgam)
infl <- data.frame(
hat = hatvalues(creditgam),
cooks = cooks.distance(creditgam),
rstandard = rstandard(creditgam),
rstudent = rstudent(creditgam)
)
infl <- infl[order(infl$cooks, decreasing = TRUE),]
head(infl)
print(summary(creditgam))
Anova(creditgam, test.statistic = "Wald")
plot(effect('Rating', creditgam))
set.seed(0)
split_obj <- initial_split(Credit, prop = 0.80)
train_df <- training(split_obj)
test_df <- testing(split_obj)
enet_pipe <- linear_reg(penalty = tune(), mixture = tune()) %>% set_engine('glmnet')
wf_full <- workflow() %>% add_model(enet_pipe) %>% add_formula(Balance_log~bs(log(Income), df = 8)+bs(log(Limit), df = 8)+bs(Rating, df = 4)+bs(log(Income), df = 8)*Student+bs(log(Limit), df = 8)*Student+Cards+Age+Education+Gender+Student+Married+Ethnicity)
wf_reduced <- workflow() %>% add_model(enet_pipe) %>% add_formula(Balance_log~bs(log(Income), df = 8)+bs(log(Limit), df = 8)+bs(log(Income), df = 8)*Student+bs(log(Limit), df = 8)*Student+Student)
folds <- vfold_cv(train_df, v = 10)
mset <- metric_set(rsq, mae, yardstick::rmse)
grid <- grid_latin_hypercube(
penalty(range = c(-6, 1)),
mixture(range = c(0, 1)),
size = 50
)
ctrl <- control_grid(save_pred = TRUE)
tune_full <- tune_grid(
wf_full, resamples = folds, grid = grid,
metrics = mset, control = ctrl
)
tune_reduced <- tune_grid(
wf_reduced, resamples = folds, grid = grid,
metrics = mset, control = ctrl
)
best_full <- select_best(tune_full, metric = 'rsq')
best_reduced <- select_best(tune_reduced, metric = 'rsq')
print("best alpha/lambda full:")
print(best_full)
print("best alpha/lambda reduced:")
print(best_reduced)
print("R2, MAE, RMSE")
print(collect_metrics(tune_full)[collect_metrics(tune_full)$penalty == best_full$penalty, ])
print("R2, MAE, RMSE")
print(collect_metrics(tune_reduced)[collect_metrics(tune_reduced)$penalty == best_reduced$penalty, ])
final_full_fit <-
finalize_workflow(wf_full, best_full) %>%
fit(train_df)
final_reduced_fit <-
finalize_workflow(wf_reduced, best_reduced) %>%
fit(train_df)
pred_full <- predict(final_full_fit, test_df) %>% bind_cols(test_df %>% select(Balance_log))
pred_red <- predict(final_reduced_fit, test_df) %>% bind_cols(test_df %>% select(Balance_log))
print("Hold Out Metrics")
mset(pred_full, truth = Balance_log, estimate = .pred)
mset(pred_red, truth = Balance_log, estimate = .pred)
tol <- 1e-6
coef_full <-
final_full_fit %>%
extract_fit_parsnip() %>%
tidy() %>%
filter(term != "(Intercept)")
chosen_full <- coef_full %>% filter(abs(estimate) > tol)
neglected_full <- coef_full %>% filter(abs(estimate) <= tol)
print("Chosen (Full Model):")
print(chosen_full)
print("Neglected (Full Model:")
print(neglected_full)
coef_reduced <-
final_reduced_fit %>%
extract_fit_parsnip %>%
tidy() %>%
filter(term != "(Intercept)")
chosen_reduced <- coef_reduced %>% filter(abs(estimate) > tol)
neglected_reduced <- coef_reduced %>% filter(abs(estimate) <= tol)
print("Chosen (Reduced Model):")
print(chosen_reduced)
print("Neglected (Reduced Model):")
print(neglected_reduced)
form_lin = Balance_log~bs(log(Income), df = 8)+bs(log(Limit), df = 8)+bs(Rating, df = 4)+bs(log(Income), df = 8)*Student+bs(log(Limit), df = 8)*Student+Cards+Age+Education+Gender+Student+Married+Ethnicity
form_bin = has_bal~Income+Limit+Cards+Age+Education+Gender+Married+Ethnicity
form_gam = Balance~Income*log(Limit)+bs(Rating, df = 4)+Cards+Age+Student+Married+Ethnicity
set.seed(100)
rmse <- function(y, yhat) sqrt(mean((y - yhat)^2, na.rm = TRUE))
gamma_deviance <- function(y, mu){
eps <- 1e-12
y <- pmax(y, eps)
mu <- pmax(mu, eps)
mean(2 * (-log(y / mu) + (y - mu) / mu))
}
folds <- vfold_cv(Credit, v = 10)
factor_vars <- c("Student", "Gender", "Married", "Ethnicity")
lvl_list <- lapply(Credit[factor_vars], function(x) levels(factor(x)))
out <- purrr::map_dfr(seq_along(folds$splits), function(i) {
sp <- folds$splits[[i]]
tr <- rsample::analysis(sp)
te <- rsample::assessment(sp)
for (v in factor_vars) {
tr[[v]] <- factor(tr[[v]], levels = lvl_list[[v]])
te[[v]] <- factor(te[[v]], levels = lvl_list[[v]])
}
x_tr <- model.matrix(form_lin, tr)[, -1, drop = FALSE]
y_tr <- tr$Balance_log
x_te <- model.matrix(form_lin, te)[, -1, drop = FALSE]
alphas <- seq(0, 1, by = 0.01)
cv_fits <- lapply(alphas, function(a) {
cv.glmnet(
x = x_tr, y = y_tr,
alpha = a,
nfolds = 10,
standardize = TRUE
)
})
best_idx <- which.min(sapply(cv_fits, function(f) min(f$cvm)))
best_cv <- cv_fits[[best_idx]]
yhat_log <- as.numeric(predict(best_cv, newx = x_te, s = 'lambda.min'))
yhat_lin <- exp(yhat_log)
rmse_lin <- rmse(te$Balance, yhat_lin)
fit_bin <- glm(form_bin, data = tr, family = binomial())
p_pos <- predict(fit_bin, newdata = te, type = 'response')
tr_pos <- tr %>% filter(Balance > 0)
fit_gam <- glm(form_gam, data = tr_pos, family = Gamma(link = 'log'))
mu_pos <- predict(fit_gam, newdata = te, type = 'response')
yhat_hurdle <- p_pos * mu_pos
rmse_hurdle <- rmse(te$Balance, yhat_hurdle)
te_pos <- te %>% filter(Balance > 0)
mu_pos_only <- predict(fit_gam, newdata = te_pos, type = 'response')
gdev <- gamma_deviance(te_pos$Balance, mu_pos_only)
tibble(
fold = i,
rmse_linear = rmse_lin,
rmse_hurdle = rmse_hurdle,
gamma_dev_pos = gdev,
best_alpha = alpha(best_idx),
best_lambda = best_cv$lambda.min
)
})
out_summary <- out %>%
summarise(
rmse_linear_mean = mean(rmse_linear),
rmse_linear_sd = sd(rmse_linear),
rmse_hurdle_mean = mean(rmse_hurdle),
rmse_hurdle_sd = sd(rmse_hurdle),
gamma_dev_pos_mean = mean(gamma_dev_pos),
gamma_dev_pos_sd = sd(gamma_dev_pos)
)
out
out_summary
form_lin = Balance_log~bs(log(Income), df = 8)+bs(log(Limit), df = 8)+bs(Rating, df = 4)+bs(log(Income), df = 8)*Student+bs(log(Limit), df = 8)*Student+Cards+Age+Education+Gender+Student+Married+Ethnicity
form_bin = has_bal~Income+Limit+Cards+Age+Education+Gender+Married+Ethnicity
form_gam = Balance~Income*log(Limit)+bs(Rating, df = 4)+Cards+Age+Student+Married+Ethnicity
set.seed(103)
rmse <- function(y, yhat) sqrt(mean((y - yhat)^2, na.rm = TRUE))
gamma_deviance <- function(y, mu){
eps <- 1e-12
y <- pmax(y, eps)
mu <- pmax(mu, eps)
mean(2 * (-log(y / mu) + (y - mu) / mu))
}
folds <- vfold_cv(Credit, v = 10)
factor_vars <- c("Student", "Gender", "Married", "Ethnicity")
lvl_list <- lapply(Credit[factor_vars], function(x) levels(factor(x)))
out <- purrr::map_dfr(seq_along(folds$splits), function(i) {
sp <- folds$splits[[i]]
tr <- rsample::analysis(sp)
te <- rsample::assessment(sp)
for (v in factor_vars) {
tr[[v]] <- factor(tr[[v]], levels = lvl_list[[v]])
te[[v]] <- factor(te[[v]], levels = lvl_list[[v]])
}
x_tr <- model.matrix(form_lin, tr)[, -1, drop = FALSE]
y_tr <- tr$Balance_log
x_te <- model.matrix(form_lin, te)[, -1, drop = FALSE]
alphas <- seq(0, 1, by = 0.01)
cv_fits <- lapply(alphas, function(a) {
cv.glmnet(
x = x_tr, y = y_tr,
alpha = a,
nfolds = 10,
standardize = TRUE
)
})
best_idx <- which.min(sapply(cv_fits, function(f) min(f$cvm)))
best_cv <- cv_fits[[best_idx]]
yhat_log <- as.numeric(predict(best_cv, newx = x_te, s = 'lambda.min'))
yhat_lin <- exp(yhat_log)
rmse_lin <- rmse(te$Balance, yhat_lin)
fit_bin <- glm(form_bin, data = tr, family = binomial())
p_pos <- predict(fit_bin, newdata = te, type = 'response')
tr_pos <- tr %>% filter(Balance > 0)
fit_gam <- glm(form_gam, data = tr_pos, family = Gamma(link = 'log'))
mu_pos <- predict(fit_gam, newdata = te, type = 'response')
yhat_hurdle <- p_pos * mu_pos
rmse_hurdle <- rmse(te$Balance, yhat_hurdle)
te_pos <- te %>% filter(Balance > 0)
mu_pos_only <- predict(fit_gam, newdata = te_pos, type = 'response')
gdev <- gamma_deviance(te_pos$Balance, mu_pos_only)
tibble(
fold = i,
rmse_linear = rmse_lin,
rmse_hurdle = rmse_hurdle,
gamma_dev_pos = gdev,
best_alpha = alpha(best_idx),
best_lambda = best_cv$lambda.min
)
})
form_lin = Balance_log~bs(log(Income), df = 8)+bs(log(Limit), df = 8)+bs(Rating, df = 4)+bs(log(Income), df = 8)*Student+bs(log(Limit), df = 8)*Student+Cards+Age+Education+Gender+Student+Married+Ethnicity
form_bin = has_bal~Income+Limit+Cards+Age+Education+Gender+Married+Ethnicity
form_gam = Balance~Income*log(Limit)+bs(Rating, df = 4)+Cards+Age+Student+Married+Ethnicity
set.seed(104)
rmse <- function(y, yhat) sqrt(mean((y - yhat)^2, na.rm = TRUE))
gamma_deviance <- function(y, mu){
eps <- 1e-12
y <- pmax(y, eps)
mu <- pmax(mu, eps)
mean(2 * (-log(y / mu) + (y - mu) / mu))
}
folds <- vfold_cv(Credit, v = 10)
factor_vars <- c("Student", "Gender", "Married", "Ethnicity", "Education")
lvl_list <- lapply(Credit[factor_vars], function(x) levels(factor(x)))
out <- purrr::map_dfr(seq_along(folds$splits), function(i) {
sp <- folds$splits[[i]]
tr <- rsample::analysis(sp)
te <- rsample::assessment(sp)
for (v in factor_vars) {
tr[[v]] <- factor(tr[[v]], levels = lvl_list[[v]])
te[[v]] <- factor(te[[v]], levels = lvl_list[[v]])
}
x_tr <- model.matrix(form_lin, tr)[, -1, drop = FALSE]
y_tr <- tr$Balance_log
x_te <- model.matrix(form_lin, te)[, -1, drop = FALSE]
alphas <- seq(0, 1, by = 0.01)
cv_fits <- lapply(alphas, function(a) {
cv.glmnet(
x = x_tr, y = y_tr,
alpha = a,
nfolds = 10,
standardize = TRUE
)
})
best_idx <- which.min(sapply(cv_fits, function(f) min(f$cvm)))
best_cv <- cv_fits[[best_idx]]
yhat_log <- as.numeric(predict(best_cv, newx = x_te, s = 'lambda.min'))
yhat_lin <- exp(yhat_log)
rmse_lin <- rmse(te$Balance, yhat_lin)
fit_bin <- glm(form_bin, data = tr, family = binomial())
p_pos <- predict(fit_bin, newdata = te, type = 'response')
tr_pos <- tr %>% filter(Balance > 0)
fit_gam <- glm(form_gam, data = tr_pos, family = Gamma(link = 'log'))
mu_pos <- predict(fit_gam, newdata = te, type = 'response')
yhat_hurdle <- p_pos * mu_pos
rmse_hurdle <- rmse(te$Balance, yhat_hurdle)
te_pos <- te %>% filter(Balance > 0)
mu_pos_only <- predict(fit_gam, newdata = te_pos, type = 'response')
gdev <- gamma_deviance(te_pos$Balance, mu_pos_only)
tibble(
fold = i,
rmse_linear = rmse_lin,
rmse_hurdle = rmse_hurdle,
gamma_dev_pos = gdev,
best_alpha = alpha(best_idx),
best_lambda = best_cv$lambda.min
)
})
out_summary <- out %>%
summarise(
rmse_linear_mean = mean(rmse_linear),
rmse_linear_sd = sd(rmse_linear),
rmse_hurdle_mean = mean(rmse_hurdle),
rmse_hurdle_sd = sd(rmse_hurdle),
gamma_dev_pos_mean = mean(gamma_dev_pos),
gamma_dev_pos_sd = sd(gamma_dev_pos)
)
out
out_summary
form_lin = Balance_log~bs(log(Income), df = 8)+bs(log(Limit), df = 8)+bs(Rating, df = 4)+bs(log(Income), df = 8)*Student+bs(log(Limit), df = 8)*Student+Cards+Age+Education+Gender+Student+Married+Ethnicity
form_bin = has_bal~Income+Limit+Cards+Age+Education+Gender+Married+Ethnicity
form_gam = Balance~Income*log(Limit)+bs(Rating, df = 4)+Cards+Age+Student+Married+Ethnicity
set.seed(103)
rmse <- function(y, yhat) sqrt(mean((y - yhat)^2, na.rm = TRUE))
gamma_deviance <- function(y, mu){
eps <- 1e-12
y <- pmax(y, eps)
mu <- pmax(mu, eps)
mean(2 * (-log(y / mu) + (y - mu) / mu))
}
folds <- vfold_cv(Credit, v = 10)
factor_vars <- c("Student", "Gender", "Married", "Ethnicity", "Education")
lvl_list <- lapply(Credit[factor_vars], function(x) levels(factor(x)))
out <- purrr::map_dfr(seq_along(folds$splits), function(i) {
sp <- folds$splits[[i]]
tr <- rsample::analysis(sp)
te <- rsample::assessment(sp)
for (v in factor_vars) {
tr[[v]] <- factor(tr[[v]], levels = lvl_list[[v]])
te[[v]] <- factor(te[[v]], levels = lvl_list[[v]])
}
x_tr <- model.matrix(form_lin, tr)[, -1, drop = FALSE]
y_tr <- tr$Balance_log
x_te <- model.matrix(form_lin, te)[, -1, drop = FALSE]
alphas <- seq(0, 1, by = 0.01)
cv_fits <- lapply(alphas, function(a) {
cv.glmnet(
x = x_tr, y = y_tr,
alpha = a,
nfolds = 10,
standardize = TRUE
)
})
best_idx <- which.min(sapply(cv_fits, function(f) min(f$cvm)))
best_cv <- cv_fits[[best_idx]]
yhat_log <- as.numeric(predict(best_cv, newx = x_te, s = 'lambda.min'))
yhat_lin <- exp(yhat_log)
rmse_lin <- rmse(te$Balance, yhat_lin)
fit_bin <- glm(form_bin, data = tr, family = binomial())
p_pos <- predict(fit_bin, newdata = te, type = 'response')
tr_pos <- tr %>% filter(Balance > 0)
fit_gam <- glm(form_gam, data = tr_pos, family = Gamma(link = 'log'))
mu_pos <- predict(fit_gam, newdata = te, type = 'response')
yhat_hurdle <- p_pos * mu_pos
rmse_hurdle <- rmse(te$Balance, yhat_hurdle)
te_pos <- te %>% filter(Balance > 0)
mu_pos_only <- predict(fit_gam, newdata = te_pos, type = 'response')
gdev <- gamma_deviance(te_pos$Balance, mu_pos_only)
tibble(
fold = i,
rmse_linear = rmse_lin,
rmse_hurdle = rmse_hurdle,
gamma_dev_pos = gdev,
best_alpha = alpha(best_idx),
best_lambda = best_cv$lambda.min
)
})
